{
  "version": 3,
  "sources": ["../../../../../node_modules/dexie/dist/modern/dexie.mjs"],
  "sourcesContent": ["/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.4, Tue May 30 2023\n *\n * https://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj || !hasOwn(obj, currentKeyPath))\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n            db._state.PR1398_maxLoop = 3;\n        }\n        catch (ex) {\n            if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                console.warn('Dexie: Need to reopen db');\n                db._close();\n                return db.open().then(() => tempTransaction(db, mode, storeNames, fn));\n            }\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.4';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            try {\n                trans.create();\n                db._state.PR1398_maxLoop = 3;\n            }\n            catch (ex) {\n                if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {\n                    console.warn('Dexie: Need to reopen db');\n                    db._close();\n                    return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));\n                }\n                return rejection(ex);\n            }\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true,\n            PR1398_maxLoop: 3\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    let hasValue = false;\n    let currentValue = undefined;\n    const observable = new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                hasValue = true;\n                currentValue = result;\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                hasValue = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n    observable.hasValue = () => hasValue;\n    observable.getValue = () => currentValue;\n    return observable;\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    if (typeof bc.unref === 'function') {\n        bc.unref();\n    }\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    if (typeof addEventListener !== 'undefined') {\n        addEventListener('storage', (ev) => {\n            if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n                const data = JSON.parse(ev.newValue);\n                if (data)\n                    propagateLocally(data.changedParts);\n            }\n        });\n    }\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n\n"],
  "mappings": "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",
  "names": ["DexieError", "type", "resolve", "reject", "props", "trans", "keys", "i", "args", "Table", "count", "ctx", "Collection", "cmp", "direction", "addRange", "ranges", "WhereClause", "indexedDB", "p", "Transaction", "db", "tables", "keyPath", "compound", "result", "req", "openCursor", "query", "ev", "hasGetAll", "Version", "primaryKey", "dxTrans", "target", "key", "state"]
}
